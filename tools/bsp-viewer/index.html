<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DoomRPG BSP Map Viewer</title>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: #1a1a1a;
            color: #fff;
        }
        h1 {
            color: #ff3333;
            margin-bottom: 10px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        .main-layout {
            display: flex;
            gap: 20px;
        }
        .map-panel {
            flex: 1;
            min-width: 0;
        }
        .script-panel {
            width: 450px;
            flex-shrink: 0;
            display: none;
        }
        .script-panel.visible {
            display: block;
        }
        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        .drop-zone {
            border: 2px dashed #555;
            border-radius: 8px;
            padding: 20px 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #2a2a2a;
        }
        .drop-zone:hover, .drop-zone.drag-over {
            border-color: #ff3333;
            background: rgba(255, 51, 51, 0.1);
        }
        input[type="file"] {
            display: none;
        }
        .info-panel {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
        }
        .info-panel.visible {
            display: block;
        }
        .info-panel h3 {
            margin: 0 0 10px 0;
            color: #ff3333;
        }
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 10px;
        }
        .info-item {
            background: #333;
            padding: 8px 12px;
            border-radius: 4px;
        }
        .info-item label {
            color: #888;
            font-size: 12px;
            display: block;
        }
        .info-item span {
            color: #fff;
            font-weight: bold;
        }
        #canvas-container {
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }
        canvas {
            display: block;
        }
        .legend {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 5px;
        }
        .legend-color {
            width: 20px;
            height: 3px;
        }
        .checkbox-group {
            display: flex;
            gap: 15px;
            background: #2a2a2a;
            padding: 10px 15px;
            border-radius: 8px;
            flex-wrap: wrap;
        }
        .checkbox-group label {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            white-space: nowrap;
        }
        .zoom-controls {
            display: flex;
            gap: 5px;
        }
        .zoom-controls button {
            background: #333;
            color: #fff;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
        }
        .zoom-controls button:hover {
            background: #444;
        }

        /* Script Panel Styles */
        .script-panel h3 {
            color: #ff3333;
            margin: 0 0 15px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .script-panel h3 span {
            font-size: 12px;
            color: #888;
            font-weight: normal;
        }
        .script-list {
            background: #2a2a2a;
            border-radius: 8px;
            max-height: calc(100vh - 200px);
            overflow-y: auto;
        }
        .tile-event {
            border-bottom: 1px solid #333;
            padding: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .tile-event:hover {
            background: #333;
        }
        .tile-event.selected {
            background: #3a3a3a;
            border-left: 3px solid #ff3333;
        }
        .tile-event-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        .tile-pos {
            font-weight: bold;
            color: #ffcc00;
        }
        .tile-index {
            font-size: 11px;
            color: #666;
        }
        .command-list {
            font-size: 12px;
            font-family: 'Monaco', 'Consolas', monospace;
        }
        .command {
            padding: 4px 8px;
            margin: 2px 0;
            background: #222;
            border-radius: 3px;
            border-left: 2px solid #666;
        }
        .command .cmd-name {
            color: #66ccff;
            font-weight: bold;
        }
        .command .cmd-args {
            color: #aaa;
            margin-left: 8px;
        }
        .command .cmd-condition {
            color: #ff9966;
            font-size: 10px;
            display: block;
            margin-top: 2px;
        }
        .command .string-preview {
            color: #99ff99;
            font-style: italic;
            display: block;
            margin-top: 2px;
            max-width: 380px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Event type colors */
        .cmd-goto { border-left-color: #ff6666; }
        .cmd-changemap { border-left-color: #ff9966; }
        .cmd-message, .cmd-dialog, .cmd-forcemessage { border-left-color: #99ff99; }
        .cmd-moveline, .cmd-openline, .cmd-closeline { border-left-color: #6699ff; }
        .cmd-show, .cmd-hide { border-left-color: #cc99ff; }
        .cmd-sound { border-left-color: #ffcc66; }
        .cmd-state { border-left-color: #66ffcc; }

        .strings-panel {
            margin-top: 20px;
            background: #2a2a2a;
            border-radius: 8px;
            padding: 12px;
            max-height: 300px;
            overflow-y: auto;
        }
        .strings-panel h4 {
            margin: 0 0 10px 0;
            color: #ff3333;
        }
        .string-item {
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 11px;
            padding: 4px 8px;
            margin: 2px 0;
            background: #222;
            border-radius: 3px;
        }
        .string-item .str-index {
            color: #666;
            margin-right: 8px;
        }
        .string-item .str-text {
            color: #99ff99;
        }

        .filter-input {
            width: 100%;
            padding: 8px 12px;
            background: #333;
            border: 1px solid #444;
            border-radius: 4px;
            color: #fff;
            margin-bottom: 10px;
        }
        .filter-input:focus {
            outline: none;
            border-color: #ff3333;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>DoomRPG BSP Map Viewer</h1>

        <div class="controls">
            <div class="drop-zone" id="drop-zone">
                Drop .bsp file here or click to select
            </div>
            <input type="file" id="file-input" accept=".bsp">

            <div class="checkbox-group">
                <label>
                    <input type="checkbox" id="show-nodes">
                    Nodes
                </label>
                <label>
                    <input type="checkbox" id="show-lines" checked>
                    Lines
                </label>
                <label>
                    <input type="checkbox" id="show-sprites" checked>
                    Sprites
                </label>
                <label>
                    <input type="checkbox" id="show-events" checked>
                    Events
                </label>
                <label>
                    <input type="checkbox" id="show-grid">
                    Grid
                </label>
                <label>
                    <input type="checkbox" id="show-blockmap">
                    BlockMap
                </label>
                <label>
                    <input type="checkbox" id="show-rulers" checked>
                    Rulers
                </label>
            </div>

            <div class="zoom-controls">
                <button id="zoom-in">+</button>
                <button id="zoom-out">-</button>
                <button id="zoom-fit">Fit</button>
            </div>
        </div>

        <div class="info-panel" id="info-panel">
            <h3>Map Info</h3>
            <div class="info-grid">
                <div class="info-item">
                    <label>Map Name</label>
                    <span id="info-name">-</span>
                </div>
                <div class="info-item">
                    <label>Nodes</label>
                    <span id="info-nodes">-</span>
                </div>
                <div class="info-item">
                    <label>Lines</label>
                    <span id="info-lines">-</span>
                </div>
                <div class="info-item">
                    <label>Sprites</label>
                    <span id="info-sprites">-</span>
                </div>
                <div class="info-item">
                    <label>Tile Events</label>
                    <span id="info-events">-</span>
                </div>
                <div class="info-item">
                    <label>ByteCodes</label>
                    <span id="info-bytecodes">-</span>
                </div>
                <div class="info-item">
                    <label>Strings</label>
                    <span id="info-strings">-</span>
                </div>
                <div class="info-item">
                    <label>Spawn</label>
                    <span id="info-spawn">-</span>
                </div>
            </div>
        </div>

        <div class="main-layout">
            <div class="map-panel">
                <div id="canvas-container">
                    <canvas id="canvas" width="900" height="700"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #00ff00;"></div>
                            <span>Nodes</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ff6600;"></div>
                            <span>Lines (walls)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ff3333; width: 8px; height: 8px; border-radius: 50%;"></div>
                            <span>Monsters</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ff6666; width: 8px; height: 8px; border-radius: 50%;"></div>
                            <span>Weapons</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #66ff66; width: 8px; height: 8px; border-radius: 50%;"></div>
                            <span>Ammo</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #66ffff; width: 8px; height: 8px; border-radius: 50%;"></div>
                            <span>Pickups</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #cc99ff; width: 8px; height: 8px; border-radius: 50%;"></div>
                            <span>Decorations/NPCs</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #6699ff; width: 8px; height: 8px; border-radius: 50%;"></div>
                            <span>Doors</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #00ffff; width: 8px; height: 8px;"></div>
                            <span>Tile Events</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ffff00; width: 8px; height: 8px; border-radius: 50%;"></div>
                            <span>Player Spawn</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: rgba(255, 0, 0, 0.3); width: 12px; height: 12px;"></div>
                            <span>Blocked Tile</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: rgba(255, 255, 0, 0.3); width: 12px; height: 12px;"></div>
                            <span>Special Tile</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="script-panel" id="script-panel">
                <h3>
                    Scripts
                    <span id="script-count"></span>
                </h3>
                <input type="text" class="filter-input" id="script-filter" placeholder="Filter by command or position...">
                <div class="script-list" id="script-list"></div>

                <div class="strings-panel" id="strings-panel">
                    <h4>Strings</h4>
                    <div id="strings-list"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Event type names and descriptions
        const EVENT_TYPES = {
            0: { name: 'EV_NONE', desc: 'No event' },
            1: { name: 'EV_GOTO', desc: 'Teleport player', format: 'xy_angle' },
            2: { name: 'EV_CHANGEMAP', desc: 'Change map', format: 'mapid' },
            3: { name: 'EV_TRIGGER', desc: 'Trigger event', format: 'xy' },
            4: { name: 'EV_MESSAGE', desc: 'Show HUD message', format: 'string' },
            5: { name: 'EV_PAIN', desc: 'Damage player', format: 'damage' },
            6: { name: 'EV_MOVELINE', desc: 'Move line (door)', format: 'line' },
            7: { name: 'EV_SHOW', desc: 'Show sprite', format: 'sprite_flags' },
            8: { name: 'EV_DIALOG', desc: 'Show dialog', format: 'string' },
            9: { name: 'EV_GIVEMAP', desc: 'Reveal automap', format: 'none' },
            10: { name: 'EV_PASSWORD', desc: 'Password prompt', format: 'pass_string' },
            11: { name: 'EV_CHANGESTATE', desc: 'Set event state', format: 'xy_state' },
            12: { name: 'EV_LOCK', desc: 'Lock door', format: 'line' },
            13: { name: 'EV_UNLOCK', desc: 'Unlock door', format: 'line' },
            14: { name: 'EV_TOGGLELOCK', desc: 'Toggle lock', format: 'line' },
            15: { name: 'EV_OPENLINE', desc: 'Open door', format: 'line' },
            16: { name: 'EV_CLOSELINE', desc: 'Close door', format: 'line' },
            17: { name: 'EV_MOVELINE2', desc: 'Move line alt', format: 'line' },
            18: { name: 'EV_HIDE', desc: 'Hide entity', format: 'xy' },
            19: { name: 'EV_NEXTSTATE', desc: 'Next state', format: 'xy' },
            20: { name: 'EV_PREVSTATE', desc: 'Prev state', format: 'xy' },
            21: { name: 'EV_INCSTAT', desc: 'Increase stat', format: 'stat_amount' },
            22: { name: 'EV_DECSTAT', desc: 'Decrease stat', format: 'stat_amount' },
            23: { name: 'EV_REQSTAT', desc: 'Require stat', format: 'stat_amount_msg' },
            24: { name: 'EV_FORCEMESSAGE', desc: 'Force message', format: 'string' },
            25: { name: 'EV_ANIM', desc: 'Spawn animation', format: 'xy_anim' },
            26: { name: 'EV_DIALOG_NOBACK', desc: 'Dialog (no back)', format: 'string' },
            27: { name: 'EV_SAVEGAME', desc: 'Save game', format: 'save' },
            28: { name: 'EV_ABORTMOVE', desc: 'Cancel movement', format: 'none' },
            29: { name: 'EV_SCREENSHAKE', desc: 'Screen shake', format: 'shake' },
            30: { name: 'EV_CHANGEFLOORCOLOR', desc: 'Change floor color', format: 'rgb' },
            31: { name: 'EV_CHANGECEILCOLOR', desc: 'Change ceiling color', format: 'rgb' },
            32: { name: 'EV_ENABLEWEAPONS', desc: 'Enable weapons', format: 'bool' },
            33: { name: 'EV_OPENSTORE', desc: 'Open store', format: 'store' },
            34: { name: 'EV_CHANGESPRITE', desc: 'Change sprite', format: 'changesprite' },
            35: { name: 'EV_SPAWNPARTICLES', desc: 'Spawn particles', format: 'particles' },
            36: { name: 'EV_REFRESHVIEW', desc: 'Refresh view', format: 'none' },
            37: { name: 'EV_WAIT', desc: 'Wait', format: 'ms' },
            38: { name: 'EV_ACTIVE_PORTAL', desc: 'Activate portal', format: 'none' },
            39: { name: 'EV_CHECK_COMPLETED_LEVEL', desc: 'Check level', format: 'level_check' },
            40: { name: 'EV_NOTE', desc: 'Add note', format: 'string' },
            41: { name: 'EV_CHECK_KEY', desc: 'Check key', format: 'key' },
            42: { name: 'EV_PLAYSOUND', desc: 'Play sound', format: 'sound' }
        };

        const KEY_NAMES = ['Green Key', 'Yellow Key', 'Blue Key', 'Red Key'];
        const STAT_NAMES = ['Health', 'Armor', 'Strength', 'Accuracy', 'Agility', 'Max Health', 'Max Armor'];

        // Sprite names from entities.db (tileIndex -> name mapping)
        const SPRITE_NAMES = {
            // Weapons (1-12)
            1: 'Axe',
            2: 'Fire Extinguisher',
            3: 'Shotgun',
            4: 'Super Shotgun',
            5: 'Assault Rifle',
            6: 'Chaingun',
            7: 'Plasma Gun',
            8: 'BFG',
            9: 'Rocket Launcher',
            10: 'Fire Wall',
            11: 'Soul Cube',
            12: 'Dog Collar',
            // Monsters (17-54)
            17: 'Zombie Private',
            18: 'Zombie Lieutenant',
            19: 'Zombie Captain',
            20: 'Zombie Commando',
            21: 'Zombie Commando 2',
            22: 'Zombie Sergant',
            23: 'Imp',
            24: 'Imp Leader',
            25: 'Imp Lord',
            26: 'Phantasm',
            27: 'Beholder',
            28: 'Rahovart',
            29: 'Infernis',
            30: 'Ogre',
            31: 'Wretched',
            32: 'Bull Demon',
            33: 'Belphegor',
            34: 'Assassin',
            35: 'Lost Soul',
            36: 'Nightmare',
            37: 'Revenant',
            38: 'Ghoul',
            39: 'Malwrath',
            40: 'Hellhound',
            41: 'Mancubus',
            42: 'Druj',
            43: 'Behemoth',
            44: 'Cacodemon',
            45: 'Watcher',
            46: 'Pinkinator',
            47: 'Archvile',
            48: 'Infernotaur',
            49: 'Baron',
            50: 'Cyberdemon',
            51: 'Pain Elemental',
            52: 'Kronos',
            53: 'Guardian',
            54: 'Spider Mastermind',
            // Keys (65-73)
            65: 'Red Key',
            66: 'Blue Key',
            67: 'Green Key',
            68: 'Yellow Key',
            69: 'Red Axe Key',
            70: 'Blue Axe Key',
            71: 'Green Axe Key',
            72: 'Yellow Axe Key',
            73: 'ID Card',
            // Ammo (81-90)
            81: 'Halon Canister',
            82: 'Bullets Small',
            83: 'Bullets Large',
            84: 'Shells Small',
            85: 'Shells Large',
            86: 'Rockets Small',
            87: 'Rockets Large',
            88: 'Cells Small',
            89: 'Cells Large',
            90: 'BFG Cells',
            // Pickups (91-102)
            91: 'Armor Bonus',
            92: 'Armor Shard',
            93: 'Security Armor',
            94: 'Combat Armor',
            95: 'Berserker',
            96: 'Medkit 10',
            97: 'Medkit 25',
            98: 'Medkit 100',
            99: 'Soulsphere',
            100: 'Credits',
            101: 'Dog Food',
            102: 'Dog Toy',
            // Decorations (128-162)
            128: 'Fire A',
            129: 'Fire B',
            130: 'Fire Pit',
            131: 'Red Candle',
            132: 'Green Candle',
            133: 'Blue Candle',
            134: 'Blue Torch',
            135: 'Red Torch',
            136: 'Light 1',
            137: 'Light 2',
            138: 'Barrel',
            139: 'Toxic Barrel',
            140: 'Gore Corpse',
            141: 'Bones',
            142: 'Table',
            143: 'Chair',
            144: 'Light 3',
            145: 'Scientist 1',
            146: 'Scientist 2',
            147: 'Marine 1',
            148: 'Marine 2',
            149: 'Civilian 1',
            150: 'Civilian 2',
            151: 'Dr. Jensen',
            152: 'Dr. Guerard',
            153: 'Crate Small',
            154: 'Crate Large',
            155: 'Box',
            156: 'Flower',
            157: 'Trash',
            158: 'Bucket',
            159: 'Vent A',
            160: 'Vent B',
            161: 'Screen',
            162: 'Terminal',
            // Doors (305-315)
            305: 'Door 1',
            306: 'Door 2',
            307: 'Door Locked',
            308: 'Door Red',
            309: 'Door Blue',
            310: 'Door Yellow',
            311: 'Door Green',
            312: 'Secret Door',
            313: 'Exit Door',
            314: 'Elevator Door',
            315: 'Airlock',
            // Special (338-360)
            338: 'Portal',
            339: 'Save Station',
            340: 'Heal Station',
            341: 'Armor Station',
            342: 'Dog',
            343: 'Computer',
            344: 'Item Vendor',
            345: 'Weapon Vendor',
            346: 'Upgrade Station',
            347: 'Teleporter Pad',
            348: 'Exit Sign',
            349: 'Vent Exit',
            350: 'Corpse Marine',
            351: 'Corpse Scientist',
            352: 'Corpse Civilian',
            353: 'Blood Pool',
            354: 'Gibs',
            355: 'Hanging Body',
            356: 'Impaled Body',
            357: 'Sparks',
            358: 'Steam',
            359: 'Electricity',
            360: 'Smoke'
        };

        function getSpriteName(id) {
            return SPRITE_NAMES[id] || `Sprite ${id}`;
        }

        // BSP Parser
        class BSPReader {
            constructor(buffer) {
                this.data = new Uint8Array(buffer);
                this.pos = 0;
            }

            readByte() {
                return this.data[this.pos++];
            }

            readShort() {
                const low = this.data[this.pos++];
                const high = this.data[this.pos++];
                let value = (high << 8) | low;
                if (value >= 0x8000) value -= 0x10000;
                return value;
            }

            readUShort() {
                const low = this.data[this.pos++];
                const high = this.data[this.pos++];
                return (high << 8) | low;
            }

            readInt() {
                const b0 = this.data[this.pos++];
                const b1 = this.data[this.pos++];
                const b2 = this.data[this.pos++];
                const b3 = this.data[this.pos++];
                return (b3 << 24) | (b2 << 16) | (b1 << 8) | b0;
            }

            readUInt() {
                const b0 = this.data[this.pos++];
                const b1 = this.data[this.pos++];
                const b2 = this.data[this.pos++];
                const b3 = this.data[this.pos++];
                return ((b3 << 24) | (b2 << 16) | (b1 << 8) | b0) >>> 0;
            }

            readShiftCoord() {
                return this.readByte() << 3;
            }

            readString(length) {
                let str = '';
                for (let i = 0; i < length; i++) {
                    const c = this.data[this.pos++];
                    if (c === 0) {
                        this.pos += length - i - 1;
                        break;
                    }
                    str += String.fromCharCode(c);
                }
                return str;
            }

            readStringWithLength() {
                const len = this.readShort();
                let str = '';
                for (let i = 0; i < len; i++) {
                    str += String.fromCharCode(this.data[this.pos++]);
                }
                return str;
            }
        }

        class BSPMap {
            constructor() {
                this.header = null;
                this.nodes = [];
                this.lines = [];
                this.sprites = [];
                this.tileEvents = [];
                this.byteCodes = [];
                this.strings = [];
                this.blockMap = new Array(1024).fill(0); // 32x32 tiles
            }

            parse(buffer) {
                const reader = new BSPReader(buffer);

                // Parse Header (33 bytes)
                this.header = {
                    mapName: reader.readString(16),
                    floorColor: { r: reader.readByte(), g: reader.readByte(), b: reader.readByte() },
                    ceilingColor: { r: reader.readByte(), g: reader.readByte(), b: reader.readByte() },
                    floorTex: reader.readByte(),
                    ceilingTex: reader.readByte(),
                    introColor: { r: reader.readByte(), g: reader.readByte(), b: reader.readByte() },
                    loadMapID: reader.readByte(),
                    mapSpawnIndex: reader.readShort(),
                    mapSpawnDir: reader.readByte(),
                    mapCameraSpawnIndex: reader.readShort()
                };

                // Parse Nodes
                const nodesLength = reader.readShort();
                this.nodes = [];
                for (let i = 0; i < nodesLength; i++) {
                    const node = {
                        x1: reader.readShiftCoord(),
                        y1: reader.readShiftCoord(),
                        x2: reader.readShiftCoord(),
                        y2: reader.readShiftCoord(),
                        arg1_high: reader.readByte(),
                        arg1_low: reader.readShiftCoord(),
                        args2_low: reader.readShort(),
                        args2_high: reader.readShort()
                    };
                    node.args1 = (node.arg1_high << 16) | node.arg1_low;
                    node.args2 = node.args2_low | (node.args2_high << 16);
                    this.nodes.push(node);
                }

                // Parse Lines
                const linesLength = reader.readShort();
                this.lines = [];
                for (let i = 0; i < linesLength; i++) {
                    this.lines.push({
                        x1: reader.readShiftCoord(),
                        y1: reader.readShiftCoord(),
                        x2: reader.readShiftCoord(),
                        y2: reader.readShiftCoord(),
                        texture: reader.readShort(),
                        flags: reader.readInt()
                    });
                }

                // Parse Sprites
                const spritesLength = reader.readShort();
                this.sprites = [];
                for (let i = 0; i < spritesLength; i++) {
                    const sprite = {
                        x: reader.readShiftCoord(),
                        y: reader.readShiftCoord(),
                        info_low: reader.readByte(),
                        info_high: reader.readShort()
                    };
                    sprite.info = sprite.info_low | (sprite.info_high << 8);
                    sprite.id = sprite.info & 0x1FF;
                    this.sprites.push(sprite);
                }

                // Parse Tile Events
                const eventsLength = reader.readShort();
                this.tileEvents = [];
                for (let i = 0; i < eventsLength; i++) {
                    const eventData = reader.readUInt();
                    const tileIndex = eventData & 0x3FF;
                    const commandIndex = (eventData & 0x7FC00) >> 10;
                    const commandCount = (eventData & 0x1F80000) >> 19;
                    const eventState = (eventData & 0x1E000000) >> 25;
                    const eventFlags = (eventData & 0xE0000000) >> 29;

                    this.tileEvents.push({
                        raw: eventData,
                        tileIndex,
                        tileX: tileIndex % 32,
                        tileY: Math.floor(tileIndex / 32),
                        commandIndex,
                        commandCount,
                        eventState,
                        eventFlags,
                        commands: [] // Will be filled after bytecode parsing
                    });
                }

                // Parse ByteCodes
                const byteCodesLength = reader.readShort();
                this.byteCodes = [];
                for (let i = 0; i < byteCodesLength; i++) {
                    const id = reader.readByte();
                    const arg1 = reader.readInt();
                    const arg2 = reader.readInt();
                    this.byteCodes.push({ id, arg1, arg2 });
                }

                // Parse Strings
                const stringsLength = reader.readShort();
                this.strings = [];
                for (let i = 0; i < stringsLength; i++) {
                    this.strings.push(reader.readStringWithLength());
                }

                // Link bytecodes to tile events
                for (const event of this.tileEvents) {
                    for (let i = 0; i < event.commandCount; i++) {
                        const cmdIdx = event.commandIndex + i;
                        if (cmdIdx < this.byteCodes.length) {
                            event.commands.push(this.byteCodes[cmdIdx]);
                        }
                    }
                }

                // Parse BlockMap (256 bytes, each byte contains flags for 4 tiles)
                this.blockMap = new Array(1024).fill(0);
                let tileIdx = 0;
                for (let j = 0; j < 256; j++) {
                    const flags = reader.readByte();
                    this.blockMap[tileIdx + 0] = (flags >> 0) & 3;
                    this.blockMap[tileIdx + 1] = (flags >> 2) & 3;
                    this.blockMap[tileIdx + 2] = (flags >> 4) & 3;
                    this.blockMap[tileIdx + 3] = (flags >> 6) & 3;
                    tileIdx += 4;
                }

                return this;
            }

            getBounds() {
                let minX = Infinity, minY = Infinity;
                let maxX = -Infinity, maxY = -Infinity;

                for (const node of this.nodes) {
                    minX = Math.min(minX, node.x1, node.x2);
                    minY = Math.min(minY, node.y1, node.y2);
                    maxX = Math.max(maxX, node.x1, node.x2);
                    maxY = Math.max(maxY, node.y1, node.y2);
                }

                for (const line of this.lines) {
                    minX = Math.min(minX, line.x1, line.x2);
                    minY = Math.min(minY, line.y1, line.y2);
                    maxX = Math.max(maxX, line.x1, line.x2);
                    maxY = Math.max(maxY, line.y1, line.y2);
                }

                for (const sprite of this.sprites) {
                    minX = Math.min(minX, sprite.x);
                    minY = Math.min(minY, sprite.y);
                    maxX = Math.max(maxX, sprite.x);
                    maxY = Math.max(maxY, sprite.y);
                }

                // Include tile events
                for (const event of this.tileEvents) {
                    const x = event.tileX * 64 + 32;
                    const y = event.tileY * 64 + 32;
                    minX = Math.min(minX, x);
                    minY = Math.min(minY, y);
                    maxX = Math.max(maxX, x);
                    maxY = Math.max(maxY, y);
                }

                return { minX, minY, maxX, maxY };
            }

            formatArg1(cmd) {
                const evType = EVENT_TYPES[cmd.id] || { name: `UNKNOWN_${cmd.id}`, format: 'raw' };
                const arg1 = cmd.arg1;

                switch (evType.format) {
                    case 'xy':
                        return `(${arg1 & 0xFF}, ${(arg1 >> 8) & 0xFF})`;
                    case 'xy_angle':
                        return `(${arg1 & 0xFF}, ${(arg1 >> 8) & 0xFF}) angle=${(arg1 >> 16) & 0xFF}`;
                    case 'xy_state':
                        return `(${arg1 & 0xFF}, ${(arg1 >> 8) & 0xFF}) state=${(arg1 >> 16) & 0xFF}`;
                    case 'xy_anim':
                        return `(${arg1 & 0xFF}, ${(arg1 >> 8) & 0xFF}) anim=${(arg1 >> 16) & 0xFFFF}`;
                    case 'string':
                        return `str[${arg1}]`;
                    case 'line':
                        return `line[${arg1}]`;
                    case 'mapid':
                        return `map=${arg1}`;
                    case 'damage':
                        return `dmg=${arg1}`;
                    case 'sprite_flags':
                        return `sprite[${arg1 & 0xFFFF}] flags=${(arg1 >> 16) & 0xFFFF}`;
                    case 'pass_string':
                        return `pass=${arg1 & 0xFF} str[${(arg1 >> 8) & 0xFFFF}]`;
                    case 'stat_amount':
                        const stat = arg1 & 0xFF;
                        const amount = (arg1 >> 8) & 0xFF;
                        return `${STAT_NAMES[stat] || `stat${stat}`} +${amount}`;
                    case 'stat_amount_msg':
                        const st = arg1 & 0xFF;
                        const amt = (arg1 >> 8) & 0xFF;
                        const msgId = (arg1 >> 16) & 0xFFFF;
                        return `${STAT_NAMES[st] || `stat${st}`} >=${amt} msg[${msgId}]`;
                    case 'save':
                        return `str[${arg1 & 0xFF}] (${(arg1 >> 8) & 0xFF},${(arg1 >> 16) & 0xFF}) a=${(arg1 >> 24) & 0xFF}`;
                    case 'shake':
                        return `dur=${arg1 & 0xFFF} int=${(arg1 >> 12) & 0xFFF} spd=${(arg1 >> 24) & 0xFF}`;
                    case 'rgb':
                        return `RGB(${arg1 & 0xFF}, ${(arg1 >> 8) & 0xFF}, ${(arg1 >> 16) & 0xFF})`;
                    case 'bool':
                        return arg1 ? 'true' : 'false';
                    case 'ms':
                        return `${arg1}ms`;
                    case 'sound':
                        return `sound[${arg1}]`;
                    case 'key':
                        return KEY_NAMES[arg1] || `key${arg1}`;
                    case 'changesprite':
                        const sx = arg1 & 0x1F;
                        const sy = (arg1 >> 5) & 0x1F;
                        const sflags = (arg1 >> 10) & 0x7;
                        const sprId = (arg1 >> 13) & 0x1FF;
                        return `(${sx},${sy}) sprite=${sprId} flags=${sflags}`;
                    case 'particles':
                        const r = arg1 & 0xFF;
                        const g = (arg1 >> 8) & 0xFF;
                        const b = (arg1 >> 16) & 0xFF;
                        const ptype = (arg1 >> 24) & 0x1F;
                        const pcount = (arg1 >> 29) & 0x7;
                        return `RGB(${r},${g},${b}) type=${ptype} count=${pcount}`;
                    case 'level_check':
                        return `str[${arg1 & 0xFFFF}] range=${(arg1 >> 16) & 0xFFFF}`;
                    case 'none':
                        return '';
                    default:
                        return arg1 !== 0 ? `0x${arg1.toString(16)}` : '';
                }
            }

            formatArg2Conditions(arg2) {
                const conditions = [];
                const triggerFlags = arg2 & 0x1FF;
                const modifyWorld = (arg2 & 0x200) !== 0;
                const keyFlags = (arg2 >> 12) & 0xF;
                const stateFlags = (arg2 >> 16) & 0x1FF;

                if (modifyWorld) conditions.push('ONE-TIME');
                if (keyFlags) {
                    const keys = [];
                    if (keyFlags & 1) keys.push('Green');
                    if (keyFlags & 2) keys.push('Yellow');
                    if (keyFlags & 4) keys.push('Blue');
                    if (keyFlags & 8) keys.push('Red');
                    conditions.push(`Req: ${keys.join('+')} Key`);
                }
                if (stateFlags) conditions.push(`State: ${stateFlags}`);
                if (triggerFlags) conditions.push(`Trigger: 0x${triggerFlags.toString(16)}`);

                return conditions.join(', ');
            }
        }

        // Renderer
        class MapRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.map = null;
                this.zoom = 1;
                this.offsetX = 0;
                this.offsetY = 0;
                this.showNodes = false;
                this.showLines = true;
                this.showSprites = true;
                this.showEvents = true;
                this.showGrid = false;
                this.showBlockMap = false;
                this.showRulers = true;
                this.selectedEvent = null;

                this.setupPanning();
            }

            setupPanning() {
                let isDragging = false;
                let lastX, lastY;

                this.canvas.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    lastX = e.clientX;
                    lastY = e.clientY;
                    this.canvas.style.cursor = 'grabbing';
                });

                window.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    const dx = e.clientX - lastX;
                    const dy = e.clientY - lastY;
                    this.offsetX += dx;
                    this.offsetY += dy;
                    lastX = e.clientX;
                    lastY = e.clientY;
                    this.render();
                });

                window.addEventListener('mouseup', () => {
                    isDragging = false;
                    this.canvas.style.cursor = 'grab';
                });

                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    this.zoom *= zoomFactor;
                    this.zoom = Math.max(0.1, Math.min(10, this.zoom));
                    this.render();
                });

                // Click to select event
                this.canvas.addEventListener('click', (e) => {
                    if (!this.map) return;
                    const rect = this.canvas.getBoundingClientRect();
                    const clickX = e.clientX - rect.left;
                    const clickY = e.clientY - rect.top;

                    // Find closest event
                    let closest = null;
                    let closestDist = 20; // Max click distance

                    for (const event of this.map.tileEvents) {
                        const x = event.tileX * 64 + 32;
                        const y = event.tileY * 64 + 32;
                        const p = this.worldToScreen(x, y);
                        const dist = Math.sqrt((p.x - clickX) ** 2 + (p.y - clickY) ** 2);
                        if (dist < closestDist) {
                            closest = event;
                            closestDist = dist;
                        }
                    }

                    this.selectedEvent = closest;
                    this.render();
                    updateScriptSelection(closest);
                });
            }

            setMap(map) {
                this.map = map;
                this.selectedEvent = null;
                this.fitToView();
            }

            fitToView() {
                if (!this.map) return;

                const bounds = this.map.getBounds();
                const mapWidth = bounds.maxX - bounds.minX;
                const mapHeight = bounds.maxY - bounds.minY;

                const padding = 50;
                const scaleX = (this.canvas.width - padding * 2) / mapWidth;
                const scaleY = (this.canvas.height - padding * 2) / mapHeight;

                this.zoom = Math.min(scaleX, scaleY);
                this.offsetX = this.canvas.width / 2 - (bounds.minX + mapWidth / 2) * this.zoom;
                this.offsetY = this.canvas.height / 2 - (bounds.minY + mapHeight / 2) * this.zoom;

                this.render();
            }

            worldToScreen(x, y) {
                return {
                    x: x * this.zoom + this.offsetX,
                    y: y * this.zoom + this.offsetY
                };
            }

            centerOnTile(tileX, tileY) {
                const x = tileX * 64 + 32;
                const y = tileY * 64 + 32;
                this.offsetX = this.canvas.width / 2 - x * this.zoom;
                this.offsetY = this.canvas.height / 2 - y * this.zoom;
                this.render();
            }

            render() {
                const ctx = this.ctx;
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                if (!this.map) return;

                if (this.showBlockMap) this.drawBlockMap();
                if (this.showGrid) this.drawGrid();
                if (this.showRulers) this.drawRulers();
                if (this.showNodes) this.drawNodes();
                if (this.showLines) this.drawLines();
                if (this.showEvents) this.drawEvents();
                if (this.showSprites) this.drawSprites();
                this.drawSpawn();
            }

            drawBlockMap() {
                const ctx = this.ctx;
                const tileSize = 64;

                for (let tileY = 0; tileY < 32; tileY++) {
                    for (let tileX = 0; tileX < 32; tileX++) {
                        const tileIdx = tileY * 32 + tileX;
                        const flag = this.map.blockMap[tileIdx];

                        if (flag === 0) continue; // Passable, skip

                        const p = this.worldToScreen(tileX * tileSize, tileY * tileSize);
                        const size = tileSize * this.zoom;

                        if (flag === 1) {
                            // Blocked (wall)
                            ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                        } else if (flag === 2) {
                            // Special (door, etc.)
                            ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                        } else if (flag === 3) {
                            // Reserved
                            ctx.fillStyle = 'rgba(255, 0, 255, 0.3)';
                        }

                        ctx.fillRect(p.x, p.y, size, size);
                    }
                }
            }

            drawGrid() {
                const ctx = this.ctx;
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 1;

                const gridSize = 64;
                const bounds = this.map.getBounds();

                const startX = Math.floor(bounds.minX / gridSize) * gridSize;
                const startY = Math.floor(bounds.minY / gridSize) * gridSize;
                const endX = Math.ceil(bounds.maxX / gridSize) * gridSize;
                const endY = Math.ceil(bounds.maxY / gridSize) * gridSize;

                for (let x = startX; x <= endX; x += gridSize) {
                    const p1 = this.worldToScreen(x, startY);
                    const p2 = this.worldToScreen(x, endY);
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                }

                for (let y = startY; y <= endY; y += gridSize) {
                    const p1 = this.worldToScreen(startX, y);
                    const p2 = this.worldToScreen(endX, y);
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                }
            }

            drawRulers() {
                const ctx = this.ctx;
                const tileSize = 64;

                ctx.font = '10px monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Draw horizontal ruler (X coordinates at top)
                for (let tileX = 0; tileX < 32; tileX++) {
                    const worldX = tileX * tileSize + tileSize / 2;
                    const p = this.worldToScreen(worldX, 0);

                    // Only draw if visible
                    if (p.x >= 0 && p.x <= this.canvas.width) {
                        // Background for readability
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        ctx.fillRect(p.x - 10, 2, 20, 14);

                        ctx.fillStyle = '#888';
                        ctx.fillText(tileX.toString(), p.x, 10);
                    }
                }

                // Draw vertical ruler (Y coordinates at left)
                ctx.textAlign = 'right';
                for (let tileY = 0; tileY < 32; tileY++) {
                    const worldY = tileY * tileSize + tileSize / 2;
                    const p = this.worldToScreen(0, worldY);

                    // Only draw if visible
                    if (p.y >= 0 && p.y <= this.canvas.height) {
                        // Background for readability
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        ctx.fillRect(2, p.y - 7, 18, 14);

                        ctx.fillStyle = '#888';
                        ctx.fillText(tileY.toString(), 18, p.y);
                    }
                }
            }

            drawNodes() {
                const ctx = this.ctx;
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.5;

                for (const node of this.map.nodes) {
                    const p1 = this.worldToScreen(node.x1, node.y1);
                    const p2 = this.worldToScreen(node.x2, node.y2);
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;
            }

            drawLines() {
                const ctx = this.ctx;
                ctx.strokeStyle = '#ff6600';
                ctx.lineWidth = 2;

                for (const line of this.map.lines) {
                    const p1 = this.worldToScreen(line.x1, line.y1);
                    const p2 = this.worldToScreen(line.x2, line.y2);
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                }
            }

            drawSprites() {
                const ctx = this.ctx;

                for (const sprite of this.map.sprites) {
                    const p = this.worldToScreen(sprite.x, sprite.y);

                    // Color-code sprites by type
                    let color = '#ff00ff'; // default magenta
                    const id = sprite.id;
                    if (id >= 1 && id <= 12) color = '#ff6666'; // weapons - red
                    else if (id >= 17 && id <= 54) color = '#ff3333'; // monsters - bright red
                    else if (id >= 65 && id <= 73) color = '#ffff00'; // keys - yellow
                    else if (id >= 81 && id <= 90) color = '#66ff66'; // ammo - green
                    else if (id >= 91 && id <= 102) color = '#66ffff'; // pickups - cyan
                    else if (id >= 128 && id <= 162) color = '#cc99ff'; // decorations/NPCs - purple
                    else if (id >= 305 && id <= 315) color = '#6699ff'; // doors - blue
                    else if (id >= 338 && id <= 360) color = '#ffcc66'; // special - orange

                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#fff';
                    ctx.font = '10px monospace';
                    const spriteName = getSpriteName(sprite.id);
                    ctx.fillText(spriteName, p.x + 6, p.y + 3);
                }
            }

            drawEvents() {
                const ctx = this.ctx;

                for (const event of this.map.tileEvents) {
                    const x = event.tileX * 64 + 32;
                    const y = event.tileY * 64 + 32;
                    const p = this.worldToScreen(x, y);

                    const isSelected = this.selectedEvent === event;

                    // Draw tile highlight
                    const tileP1 = this.worldToScreen(event.tileX * 64, event.tileY * 64);
                    const tileSize = 64 * this.zoom;

                    ctx.fillStyle = isSelected ? 'rgba(0, 255, 255, 0.3)' : 'rgba(0, 255, 255, 0.1)';
                    ctx.fillRect(tileP1.x, tileP1.y, tileSize, tileSize);

                    // Draw event marker
                    ctx.fillStyle = isSelected ? '#ffffff' : '#00ffff';
                    ctx.fillRect(p.x - 4, p.y - 4, 8, 8);

                    if (isSelected) {
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(tileP1.x, tileP1.y, tileSize, tileSize);
                    }
                }
            }

            drawSpawn() {
                if (!this.map.header) return;

                const ctx = this.ctx;
                const spawnIndex = this.map.header.mapSpawnIndex;
                const spawnX = (spawnIndex % 32) * 64 + 32;
                const spawnY = Math.floor(spawnIndex / 32) * 64 + 32;
                const p = this.worldToScreen(spawnX, spawnY);

                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
                ctx.fill();

                const dir = this.map.header.mapSpawnDir;
                const angle = (dir / 256) * Math.PI * 2;
                const arrowLen = 15;
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(p.x, p.y);
                ctx.lineTo(p.x + Math.cos(angle) * arrowLen, p.y - Math.sin(angle) * arrowLen);
                ctx.stroke();
            }
        }

        // UI
        const canvas = document.getElementById('canvas');
        const renderer = new MapRenderer(canvas);
        let currentMap = null;

        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('file-input');
        const infoPanel = document.getElementById('info-panel');
        const scriptPanel = document.getElementById('script-panel');
        const scriptList = document.getElementById('script-list');
        const stringsList = document.getElementById('strings-list');
        const scriptFilter = document.getElementById('script-filter');

        function loadFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const map = new BSPMap();
                    map.parse(e.target.result);
                    currentMap = map;

                    renderer.setMap(map);
                    updateInfo(map);
                    updateScriptList(map);
                    updateStringsList(map);

                    infoPanel.classList.add('visible');
                    scriptPanel.classList.add('visible');
                    canvas.style.cursor = 'grab';
                } catch (err) {
                    alert('Error parsing BSP file: ' + err.message);
                    console.error(err);
                }
            };
            reader.readAsArrayBuffer(file);
        }

        function updateInfo(map) {
            document.getElementById('info-name').textContent = map.header.mapName || '(unnamed)';
            document.getElementById('info-nodes').textContent = map.nodes.length;
            document.getElementById('info-lines').textContent = map.lines.length;
            document.getElementById('info-sprites').textContent = map.sprites.length;
            document.getElementById('info-events').textContent = map.tileEvents.length;
            document.getElementById('info-bytecodes').textContent = map.byteCodes.length;
            document.getElementById('info-strings').textContent = map.strings.length;
            document.getElementById('info-spawn').textContent =
                `(${map.header.mapSpawnIndex % 32}, ${Math.floor(map.header.mapSpawnIndex / 32)})`;
        }

        function updateScriptList(map, filter = '') {
            scriptList.innerHTML = '';
            document.getElementById('script-count').textContent = `${map.tileEvents.length} events`;

            const filterLower = filter.toLowerCase();

            for (const event of map.tileEvents) {
                // Build searchable text
                let searchText = `${event.tileX},${event.tileY} `;
                for (const cmd of event.commands) {
                    const evType = EVENT_TYPES[cmd.id] || { name: `UNKNOWN_${cmd.id}` };
                    searchText += evType.name + ' ';
                }

                if (filter && !searchText.toLowerCase().includes(filterLower)) {
                    continue;
                }

                const div = document.createElement('div');
                div.className = 'tile-event';
                div.dataset.tileX = event.tileX;
                div.dataset.tileY = event.tileY;

                let html = `
                    <div class="tile-event-header">
                        <span class="tile-pos">(${event.tileX}, ${event.tileY})</span>
                        <span class="tile-index">idx: ${event.tileIndex}</span>
                    </div>
                    <div class="command-list">
                `;

                for (const cmd of event.commands) {
                    const evType = EVENT_TYPES[cmd.id] || { name: `UNKNOWN_${cmd.id}`, desc: 'Unknown' };
                    const argStr = map.formatArg1(cmd);
                    const conditions = map.formatArg2Conditions(cmd.arg2);

                    // Determine CSS class for color coding
                    let cmdClass = '';
                    if ([1].includes(cmd.id)) cmdClass = 'cmd-goto';
                    if ([2].includes(cmd.id)) cmdClass = 'cmd-changemap';
                    if ([4, 8, 24, 26].includes(cmd.id)) cmdClass = 'cmd-message';
                    if ([6, 15, 16, 17].includes(cmd.id)) cmdClass = 'cmd-moveline';
                    if ([7, 18].includes(cmd.id)) cmdClass = 'cmd-show';
                    if ([42].includes(cmd.id)) cmdClass = 'cmd-sound';
                    if ([11, 19, 20].includes(cmd.id)) cmdClass = 'cmd-state';

                    html += `<div class="command ${cmdClass}">`;
                    html += `<span class="cmd-name">${evType.name}</span>`;
                    if (argStr) html += `<span class="cmd-args">${argStr}</span>`;

                    // Show string preview for message/dialog events
                    if ([4, 8, 24, 26, 40].includes(cmd.id) && cmd.arg1 < map.strings.length) {
                        const str = map.strings[cmd.arg1];
                        html += `<span class="string-preview">"${str.replace(/\|/g, ' ')}"</span>`;
                    }

                    if (conditions) {
                        html += `<span class="cmd-condition">${conditions}</span>`;
                    }
                    html += '</div>';
                }

                html += '</div>';
                div.innerHTML = html;

                div.addEventListener('click', () => {
                    document.querySelectorAll('.tile-event').forEach(el => el.classList.remove('selected'));
                    div.classList.add('selected');
                    renderer.selectedEvent = event;
                    renderer.centerOnTile(event.tileX, event.tileY);
                });

                scriptList.appendChild(div);
            }
        }

        function updateScriptSelection(event) {
            document.querySelectorAll('.tile-event').forEach(el => {
                if (event && el.dataset.tileX == event.tileX && el.dataset.tileY == event.tileY) {
                    el.classList.add('selected');
                    el.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                } else {
                    el.classList.remove('selected');
                }
            });
        }

        function updateStringsList(map) {
            stringsList.innerHTML = '';

            for (let i = 0; i < map.strings.length; i++) {
                const div = document.createElement('div');
                div.className = 'string-item';
                div.innerHTML = `<span class="str-index">[${i}]</span><span class="str-text">${map.strings[i].replace(/\|/g, '|')}</span>`;
                stringsList.appendChild(div);
            }
        }

        // Event listeners
        dropZone.addEventListener('click', () => fileInput.click());

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('drag-over');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
            if (e.dataTransfer.files.length > 0) {
                loadFile(e.dataTransfer.files[0]);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                loadFile(e.target.files[0]);
            }
        });

        scriptFilter.addEventListener('input', (e) => {
            if (currentMap) {
                updateScriptList(currentMap, e.target.value);
            }
        });

        // Checkboxes
        document.getElementById('show-nodes').addEventListener('change', (e) => {
            renderer.showNodes = e.target.checked;
            renderer.render();
        });

        document.getElementById('show-lines').addEventListener('change', (e) => {
            renderer.showLines = e.target.checked;
            renderer.render();
        });

        document.getElementById('show-sprites').addEventListener('change', (e) => {
            renderer.showSprites = e.target.checked;
            renderer.render();
        });

        document.getElementById('show-events').addEventListener('change', (e) => {
            renderer.showEvents = e.target.checked;
            renderer.render();
        });

        document.getElementById('show-grid').addEventListener('change', (e) => {
            renderer.showGrid = e.target.checked;
            renderer.render();
        });

        document.getElementById('show-blockmap').addEventListener('change', (e) => {
            renderer.showBlockMap = e.target.checked;
            renderer.render();
        });

        document.getElementById('show-rulers').addEventListener('change', (e) => {
            renderer.showRulers = e.target.checked;
            renderer.render();
        });

        // Zoom controls
        document.getElementById('zoom-in').addEventListener('click', () => {
            renderer.zoom *= 1.2;
            renderer.render();
        });

        document.getElementById('zoom-out').addEventListener('click', () => {
            renderer.zoom *= 0.8;
            renderer.render();
        });

        document.getElementById('zoom-fit').addEventListener('click', () => {
            renderer.fitToView();
        });

        // Initial render
        renderer.render();
    </script>
</body>
</html>
